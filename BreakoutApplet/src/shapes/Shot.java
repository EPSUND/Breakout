package shapes;
import gui.BreakoutCanvas;

import java.util.Vector;

import main.Breakout;
import main.BrickConfiguration;
import main.Player;

/**
 * A class representing a shot fired by a shooter
 * @author Erik
 *
 */
public class Shot extends Circle {
	private static final String SHOT_IMAGE_NAME = "shot.bmp";
	private static final float SHOT_RADIUS = 5;
	private static final float SHOT_MAX_VEL = 2;
	
	private float xVel, yVel;
	private boolean isAlive;
	
	/**
	 * The constructor of Shot
	 * @param x The x-value of the shot
	 * @param y The y-value of the shot
	 * @param xDir The x direction of the shot
	 * @param yDir The y direction of the shot
	 */
	public Shot(float x, float y, float xDir, float yDir)
	{
		super(x, y, SHOT_RADIUS, SHOT_IMAGE_NAME);
		
		this.xVel = xDir * SHOT_MAX_VEL;
		this.yVel = yDir * SHOT_MAX_VEL;
		
		this.radius = SHOT_RADIUS;
		this.isAlive = true;
	}
	
	/**
	 * Updates the position of the shot
	 * @param pf_width The width of the playing field
	 * @param pf_height The height of the playing field
	 * @param player The player object
	 * @param bricks The level's bricks
	 * @param brickConfigurations The game's brick configurations
	 * @param canvas The game's canvas
	 * @return If the shot has hit something or has moved outside the playing field
	 */
	public boolean updatePosition(float pf_width, float pf_height, Player player, Vector<Brick> bricks, Vector<BrickConfiguration> brickConfigurations, BreakoutCanvas canvas) {
		/*Update the shot's position*/
		x += xVel;//(speed * xDir);
		y += yVel;//(speed * yDir);
		
		int score_sum = 0;
		boolean bricksStillInPlay = false;
		
		/*Resolve any potential collision between the shot and the level's bricks*/
		for(Brick brick : bricks) {
			if(brick.getIsAlive()) {//Only check bricks that are alive
				score_sum += resolveCollision(brick);
				brick.updateBrickColor(brickConfigurations);
				bricksStillInPlay = true;
			}
		}
		
		/*If no bricks are still in play has the player completed the level*/
		if(!bricksStillInPlay) {
			player.setLevelCompleted(true);
		}
		
		/*Add the points gained from hitting bricks*/
		player.addPoints(score_sum);
		
		//The shot has hit something and should be removed
		if(!isAlive)
		{
			return true;
		}
		
		/*Check if the shot has moved outside the canvas*/
		return maintainBounderies(pf_width, pf_height);
	}
	
	/**
	 * Checks if shot is outside the playing field
	 * @param pf_width The width of the playing field
	 * @param pf_height The height of the playing field
	 * @return If the shot is outside the playing field
	 */
	public boolean maintainBounderies(float pf_width, float pf_height) {
		/*Check if the shot is outside the canvas bounderies*/
		if(x - radius < 0) {
			return true;
		}
		else if((x + radius) > pf_width) {
			return true;
		}
		
		if(y - radius < Breakout.STATUS_FIELD_HEIGHT) {
			return true;
		}
		else if(y + radius > pf_height) {
			return true;
		}
		
		return false;
	}
	
	/**
	 * Resolve a collision between a shot and a brick
	 * @param brick The brick to check for a collision with
	 * @return The score generated by hitting the brick, if we hit the brick. If not is 0 returned.
	 */
	public int resolveCollision(Brick brick)
	{
		/*Get the center point of the brick*/
		float centerX = (2 * brick.x + brick.width) / 2;
		float centerY = (2 * brick.y + brick.height) / 2;
		
		/*Translate the shot's center point*/
		float sTransX = x - centerX;
		float sTransY = y - centerY;
		
		/*Get a (width / 2) and b (height / 2)*/
		float a = brick.width / 2;
		float b = brick.height / 2;
		
		/*Broad-phase collision detection: Checks if the brick and the shot can possibly collide*/
		if(((sTransX < (-a - radius)) || (sTransX > (a + radius))) &&
		   ((sTransY < (-b - radius)) || (sTransY > (b + radius)))){
			return 0;
		}
		
		if((sTransX > -a) && (sTransX < a) &&
				(sTransY > -b) && (sTransY < b)){//If the shot's center point is completly inside the brick
			/*Signal a hit to the brick*/
			brick.hit();
			/*Pull the shot out of play*/
			isAlive = false;
			
			/*Check if the hit elminated the brick*/
			if(brick.getIsAlive())
			{
				/*Award the player with the hit points*/
				return Breakout.HIT_SCORE;
			}
			else
			{
				/*Award the player the brick's score*/
				return brick.getScore();
			}
		}
		else if((sTransX > -a) && (sTransX < a)) {//The shot's center point is either over or under the rectangle 
			if((sTransY < b + radius) && (sTransY > b)) {//If the shot is intersecting the rectangle's uppermost edge
				/*Signal a hit to the brick*/
				brick.hit();
				/*Pull the shot out of play*/
				isAlive = false;
				
				/*Check if the hit elminated the brick*/
				if(brick.getIsAlive())
				{
					/*Award the player with the hit points*/
					return Breakout.HIT_SCORE;
				}
				else
				{
					/*Award the player the brick's score*/
					return brick.getScore();
				}
			}
			else if((sTransY > -b - radius) && (sTransY < -b)) {//If the shot is intersecting the rectangle's lowermost edge
				/*Signal a hit to the brick*/
				brick.hit();
				/*Pull the shot out of play*/
				isAlive = false;
				
				/*Check if the hit elminated the brick*/
				if(brick.getIsAlive())
				{
					/*Award the player with the hit points*/
					return Breakout.HIT_SCORE;
				}
				else
				{
					/*Award the player the brick's score*/
					return brick.getScore();
				}
			}
			else {//Should never happen
				return 0;
			}
		}
		else if((sTransY > -b) && (sTransY < b)) {//The shot's center point is either to the left or right of the rectangle
			if((sTransX < a + radius) && (sTransX > a)) {//If the shot is intersecting the rectangle's rightmost edge
				/*Signal a hit to the brick*/
				brick.hit();
				/*Pull the shot out of play*/
				isAlive = false;
				
				/*Check if the hit elminated the brick*/
				if(brick.getIsAlive())
				{
					/*Award the player with the hit points*/
					return Breakout.HIT_SCORE;
				}
				else
				{
					/*Award the player the brick's score*/
					return brick.getScore();
				}
			}
			else if((sTransX > -a - radius) && (sTransX < -a)) {//If the shot is intersecting the rectangle's leftmost edge
				/*Signal a hit to the brick*/
				brick.hit();
				/*Pull the shot out of play*/
				isAlive = false;
				
				/*Check if the hit elminated the brick*/
				if(brick.getIsAlive())
				{
					/*Award the player with the hit points*/
					return Breakout.HIT_SCORE;
				}
				else
				{
					/*Award the player the brick's score*/
					return brick.getScore();
				}
			}
			else {//Should never happen
				return 0;
			}
		}
		else if(Math.pow((Math.abs(sTransX) - a), 2) + 
				Math.pow((Math.abs(sTransY) - b), 2) < Math.pow(radius, 2)) {//If the shot's center point is closest to one of the rectangle's corners
			/*Signal a hit to the brick*/
			brick.hit();
			/*Pull the shot out of play*/
			isAlive = false;
			
			/*Check if the hit elminated the brick*/
			if(brick.getIsAlive())
			{
				/*Award the player with the hit points*/
				return Breakout.HIT_SCORE;
			}
			else
			{
				/*Award the player the brick's score*/
				return brick.getScore();
			}
		}
		else {//The shot is not colliding with the brick
			return 0;
		}
	}

	/**
	 * Gets if the shot is alive
	 * @return If the shot is alive
	 */
	public boolean isAlive() {
		return isAlive;
	}
}
